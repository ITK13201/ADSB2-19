# Description

## Encode

0bit目から見ていって，偶数bitと奇数bitでエンコード後の文字列を分ける．

- 偶数bit
  - 0: A
  - 1: G
- 奇数bit
  - 0: T
  - 1: C

最後の1つにだけ2bit分の情報を持たせ，DNAのsizeを下げる．
最後の2bitを小さい方からc1, c2とすると，

- (c1, c2)
  - (0, 0): A
  - (0, 1): T
  - (1, 0): G
  - (1, 1): C


## Decode

### とりあえず変換

N回読み出してそれを変換して二次元配列に格納していく．それぞれ

- A: 0
- T: 1
- G: 2
- C: 3
- 空列: 4

### 誤り訂正

一文字ずつ判別してansに格納する．
その際に読み取りミスが原因で出たインデックスのずれを後で修正．

#### 多数決

偶奇と0,1 or 2,3 で判別していく．

1. 偶奇完全不一致 -> ansに0を格納し，打ち切って次のインデックスへ
2. 偶奇一致 and 0,1 が多い -> ansに0を格納
3. 偶奇一致 and 2,3 が多い -> ansに1を格納

完全一致の場合，すべてのポイントを1つ増やして次のインデックスへ．

#### ポイント調整

i: ansのインデックス  
j: iとの差分

iの直後M文字分を比較してポイントを調整する．

1. 多数決で0,1,2,3を判定する．この際，偶奇での足切りを含む．(最後の方で空列がある場合には空列までの差分を保存しておく．)
2. (1.) で決定した文字列と最初に変換した文字列を編集距離比較(±2文字分)．完全一致しなかった場合でも多数決で編集距離が一番少ないものにする．

#### 最後のdecode

多数決で判定

